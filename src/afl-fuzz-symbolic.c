#include "afl-fuzz.h"

/**
 * We should symbolc_path is exist before bump into this function.
 * 
 *
 * Should be called only when fuzzer stucks.
 * We use S2E as our symbolic execution engine, 
 * this function prepares all things needed by
 * symbolic execution. Firstly, we apply 
 * taint inference to current seed, and send 
 * the seed with critical bytes to S2E. Wrapper
 * in S2E reads critical bytes as filename.symranges.
 * here we manually prepare the critical bytes file as
 * filename.symranges.
 * WANT TO DO
 * We try to decide which branch we want S2E to solve for us.
 * we need to find out which branch contains uncovered edge, and
 * this cannot be done in current AFL model. To obtain this 
 * information, we need to modify instrumentation part and do this 
 * in compile time. But now, we just try to construct a hybrid 
 * fuzzing system with only critical bytes maked as symbolic input 
 * in symbolic execution.
 */
u8 invoke_symbolic(afl_state_t *afl, u8 *buf, u8 *orig_buf, u32 len) {
  
  FILE *f;
  u8* fn, *new_fn, *s2e_path, *s2e_out_dir;
  struct tainted *t;
  s32 status;
  pid_t pid;

  fprintf(stderr, "try to invoke symbolic engine...\n");
  // we assume fuzzer stucks now, and we will invoke the S2E, a 
  // symbolic execution engine, to do single concolic execution.

  // Before launching the symbolic engine, we want to obtain critical
  // bytes for current seed first, this can be used to reduce the symbolic
  // input size dramatically.
  
  // cmplog mode, since we need cmplog support
  if (unlikely(afl->shm.cmplog_mode)) {  
    memcpy(buf, orig_buf, len);
    if (taint_inference_stage(afl, buf, orig_buf, len, TAINT_CMP)) {

      return 1;

    }

    afl->tainted_seed[TAINT_CMP]++;
  
    fprintf(stderr, "write current seed to %s/poc\n", afl->symbolic_path);
    // write current seed and corresponding critical bytes file to 
    // S2E project dir
    fn = alloc_printf("%s/poc", afl->symbolic_path);
    f = create_ffile(fn);
    
    fwrite(buf, len, 1, f);

    fclose(f);
    ck_free(fn);
    
    fprintf(stderr, "write critical bytes file to %s/poc.symranges\n", afl->symbolic_path);
    fn = alloc_printf("%s/poc.symranges", afl->symbolic_path);
    f = create_ffile(fn);

    t = afl->queue_cur->c_bytes[TAINT_CMP];
  
    while(t != NULL) {
    
      fprintf(f, "%u-%u\n", t->pos, t->len);
      t = t->next;
    
    }

    fclose(f);
    ck_free(fn);
    
    // check sync_id since we want to use this mechanism to sync our 
    // testcases from symbolic
    if (!afl->sync_id) {

      PFATAL("For synchronizing with symbolic engine, we need sync_id");

    }

    s2e_path = alloc_printf("%s/launch-s2e.sh", afl->symbolic_path);
    s2e_out_dir = alloc_printf("%s/s2e-out-%d", afl->sync_dir, afl->queue_cur->id);
    
    // create output dir
    /*if (mkdir(s2e_out_dir, 0700)) { 
      
      if (errno != EEXIST) {

        PFATAL("Unable to create '%s'", s2e_out_dir);

      }

      if (rmdir(s2e_out_dir) < 0) { 

        PFATAL("Delete directory failed");
      
      }

      if (mkdir(s2e_out_dir, 0700)) {

        PFATAL("Unable to create '%s'", s2e_out_dir);

      }

    }*/
    
    // launch S2E
    pid = fork();

    if (pid == 0) {
      
      // set S2E output directory to sync directory
      setenv("S2E_OUTPUT_DIR", s2e_out_dir, 1);
      
      // change directory to s2e directory
      if (chdir(afl->symbolic_path) < 0) {
        
        PFATAL("Chdir failed");
         
      }

      char *argv[1];
      argv[0] = NULL;
      
      fprintf(stderr, "launch s2e %s\n", s2e_path);
      execv(s2e_path, argv);
      
      WARNF("Execv failed in invoke_symbolic.");

    }
    else if (pid > 0) {
      
      // we are not going to wait S2E terminates, since it's quite slow,
      // we put testcases generated by S2E in sync_dir, and use sync_fuzzer to
      // synchronize. This should be a better way.
      if (waitpid(pid, &status, 0) < 0) {
      
        PFATAL("Wait failed");

      }

      // rename s2e-out-*/testcase- to queue to match the
      // format of afl sync dir
      fn = alloc_printf("%s/testcase-", s2e_out_dir);
      new_fn = alloc_printf("%s/queue", s2e_out_dir);
      
      if (rename(fn, new_fn) < 0) {

        PFATAL("Rename testcase- failed");

      }

      // create directory .synced 
      fn = alloc_printf("%s/.synced/", afl->out_dir);

      if (mkdir(fn, 0700) && (errno != EEXIST)) {

        PFATAL("Unable to create '%s'", fn);

      }

      // sync 
      sync_fuzzers(afl);
      
      ck_free(fn);
      ck_free(new_fn);

    }
    else {
      
      PFATAL("Fork failed");

    }

    ck_free(s2e_path);
    ck_free(s2e_out_dir);

  }
  
  // memlog mode is not support yet, since it does not have proper S2E plugin to 
  // cooperate with, and S2E does not handle symbolic pointer well currently.
  return 0;

}